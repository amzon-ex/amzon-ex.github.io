<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="http://code.jquery.com/jquery-3.2.1.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/mousetrap/1.4.6/mousetrap.min.js"></script>
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="/css/searchoverlay.css" rel="stylesheet"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Customizing the Terminal Prompt with oh-my-posh | ProgBlog</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Customizing the Terminal Prompt with oh-my-posh" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The module oh-my-posh is the Windows equivalent of oh-my-zsh for Linux. It can help create pretty prompts which may provide visual aids with git (among other things?1). I stumbled upon this idea on this blog, but really, it’s a very commonly used module. I’m going to use the Windows Terminal. Installing a NerdFont Shell-independent installation in Windows Remarks Only for Powershell Installing a NerdFont oh-my-posh uses glyphs that are not present in standard fonts. To get them, we need to install one of many NerdFonts from the website. Windows Terminal by default uses Cascadia fonts. I prefer to use Fira Code instead. So we can just search for Fira Code in the website (or download any font - doesn’t really matter). The fonts will be downloaded in a zip format. Install and check the name of the font in the font file. In my case, it is “FiraCode Nerd Font”. Now we can go to Terminal settings by pressing Ctrl+Shift+, which will open the settings in JSON format, and add this to the &quot;profiles&quot;: &quot;defaults&quot;: key: &quot;font&quot;: { &quot;face&quot;: &quot;FiraCode Nerd Font&quot; } This is the place where we can adjust the size and style of the font if desired, e.g &quot;size&quot;: 10. Save and Terminal refreshes, now using the installed NerdFont. Shell-independent installation in Windows From this guide. First, we need to install oh-my-posh. We can do this using winget, the package manager CLI in Windows: winget install JanDeDobbeleer.OhMyPosh Now we will have the oh-my-posh.exe application which we can use to customize our prompt. For WSL, this will be oh-my-posh-wsl instead. Themes are present at the location ~\AppData\Local\Programs\oh-my-posh\themes. We can list all the theme names: ls ~\AppData\Local\Programs\oh-my-posh\themes\ which are just JSON files with the name format *.omp.json. To actually view the themes in action, however, we can run the following command: Get-ChildItem -Path &quot;~\AppData\Local\Programs\oh-my-posh\themes\*&quot; -Include &#39;*.omp.json&#39; | Sort-Object Name | ForEach-Object -Process { $esc = [char]27 Write-Host &quot;&quot; Write-Host &quot;$esc[1m$($_.BaseName)$esc[0m&quot; Write-Host &quot;&quot; oh-my-posh --config $($_.FullName) --pwd $PWD Write-Host &quot;&quot; } which basically loops through all the JSON files in the folder and prints a custom prompt for each. To actually change the prompt, we can run oh-my-posh --init --shell pwsh --config ~/AppData/Local/Programs/oh-my-posh/themes/jandedobbeleer.omp.json | Invoke-Expression in Powershell, or eval &quot;$(oh-my-posh-wsl --init --shell bash --config $USERPROFILE/AppData/Local/Programs/oh-my-posh/themes/jandedobbeleer.omp.json)&quot; on bash in WSL.2 To make changes permanent, we need to add this command to the profile of the respective shells ($profile for Powershell and .bashrc for bash). Remarks Even though it seems like a PITA3 to write such a complicated path again and again (especially in WSL), once we’ve written it, all we have to do is modify the name of the theme (here jandedobbeleer) and not touch the path at all. However, if we are to modify these themes to our liking, it is wise to copy the JSON files to another location and make necessary changes, and then make the shell profile point to that location. Only for Powershell To start with, we run: Install-Module oh-my-posh -Scope CurrentUser in Powershell. This installs the oh-my-posh module for the current user (admin privileges not required?). For instance, it marks the root folder of this Jekyll website with a little ruby icon (Jekyll uses Ruby and the root folder has a Gemfile) or a Python symbol when python files are present. &#8617; The environment variable $USERPROFILE does not exist by default. It has to be forwarded from Windows to WSL via the WSLENV variable: setx WSLENV USERPROFILE/up and after a session restart, the Windows environment variable %USERPROFILE% containing the path to the user profile is available at $USERPROFILE in WSL (translated to a Linux-style path, the /p switch does this). (Source) &#8617; Pain-In-The-Ass. &#8617;" />
<meta property="og:description" content="The module oh-my-posh is the Windows equivalent of oh-my-zsh for Linux. It can help create pretty prompts which may provide visual aids with git (among other things?1). I stumbled upon this idea on this blog, but really, it’s a very commonly used module. I’m going to use the Windows Terminal. Installing a NerdFont Shell-independent installation in Windows Remarks Only for Powershell Installing a NerdFont oh-my-posh uses glyphs that are not present in standard fonts. To get them, we need to install one of many NerdFonts from the website. Windows Terminal by default uses Cascadia fonts. I prefer to use Fira Code instead. So we can just search for Fira Code in the website (or download any font - doesn’t really matter). The fonts will be downloaded in a zip format. Install and check the name of the font in the font file. In my case, it is “FiraCode Nerd Font”. Now we can go to Terminal settings by pressing Ctrl+Shift+, which will open the settings in JSON format, and add this to the &quot;profiles&quot;: &quot;defaults&quot;: key: &quot;font&quot;: { &quot;face&quot;: &quot;FiraCode Nerd Font&quot; } This is the place where we can adjust the size and style of the font if desired, e.g &quot;size&quot;: 10. Save and Terminal refreshes, now using the installed NerdFont. Shell-independent installation in Windows From this guide. First, we need to install oh-my-posh. We can do this using winget, the package manager CLI in Windows: winget install JanDeDobbeleer.OhMyPosh Now we will have the oh-my-posh.exe application which we can use to customize our prompt. For WSL, this will be oh-my-posh-wsl instead. Themes are present at the location ~\AppData\Local\Programs\oh-my-posh\themes. We can list all the theme names: ls ~\AppData\Local\Programs\oh-my-posh\themes\ which are just JSON files with the name format *.omp.json. To actually view the themes in action, however, we can run the following command: Get-ChildItem -Path &quot;~\AppData\Local\Programs\oh-my-posh\themes\*&quot; -Include &#39;*.omp.json&#39; | Sort-Object Name | ForEach-Object -Process { $esc = [char]27 Write-Host &quot;&quot; Write-Host &quot;$esc[1m$($_.BaseName)$esc[0m&quot; Write-Host &quot;&quot; oh-my-posh --config $($_.FullName) --pwd $PWD Write-Host &quot;&quot; } which basically loops through all the JSON files in the folder and prints a custom prompt for each. To actually change the prompt, we can run oh-my-posh --init --shell pwsh --config ~/AppData/Local/Programs/oh-my-posh/themes/jandedobbeleer.omp.json | Invoke-Expression in Powershell, or eval &quot;$(oh-my-posh-wsl --init --shell bash --config $USERPROFILE/AppData/Local/Programs/oh-my-posh/themes/jandedobbeleer.omp.json)&quot; on bash in WSL.2 To make changes permanent, we need to add this command to the profile of the respective shells ($profile for Powershell and .bashrc for bash). Remarks Even though it seems like a PITA3 to write such a complicated path again and again (especially in WSL), once we’ve written it, all we have to do is modify the name of the theme (here jandedobbeleer) and not touch the path at all. However, if we are to modify these themes to our liking, it is wise to copy the JSON files to another location and make necessary changes, and then make the shell profile point to that location. Only for Powershell To start with, we run: Install-Module oh-my-posh -Scope CurrentUser in Powershell. This installs the oh-my-posh module for the current user (admin privileges not required?). For instance, it marks the root folder of this Jekyll website with a little ruby icon (Jekyll uses Ruby and the root folder has a Gemfile) or a Python symbol when python files are present. &#8617; The environment variable $USERPROFILE does not exist by default. It has to be forwarded from Windows to WSL via the WSLENV variable: setx WSLENV USERPROFILE/up and after a session restart, the Windows environment variable %USERPROFILE% containing the path to the user profile is available at $USERPROFILE in WSL (translated to a Linux-style path, the /p switch does this). (Source) &#8617; Pain-In-The-Ass. &#8617;" />
<link rel="canonical" href="http://localhost:4000/tweaks/2021/10/22/change-term-prompt-omp.html" />
<meta property="og:url" content="http://localhost:4000/tweaks/2021/10/22/change-term-prompt-omp.html" />
<meta property="og:site_name" content="ProgBlog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-10-22T16:00:00+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Customizing the Terminal Prompt with oh-my-posh" />
<script type="application/ld+json">
{"headline":"Customizing the Terminal Prompt with oh-my-posh","dateModified":"2021-10-22T16:00:00+05:30","datePublished":"2021-10-22T16:00:00+05:30","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/tweaks/2021/10/22/change-term-prompt-omp.html"},"url":"http://localhost:4000/tweaks/2021/10/22/change-term-prompt-omp.html","description":"The module oh-my-posh is the Windows equivalent of oh-my-zsh for Linux. It can help create pretty prompts which may provide visual aids with git (among other things?1). I stumbled upon this idea on this blog, but really, it’s a very commonly used module. I’m going to use the Windows Terminal. Installing a NerdFont Shell-independent installation in Windows Remarks Only for Powershell Installing a NerdFont oh-my-posh uses glyphs that are not present in standard fonts. To get them, we need to install one of many NerdFonts from the website. Windows Terminal by default uses Cascadia fonts. I prefer to use Fira Code instead. So we can just search for Fira Code in the website (or download any font - doesn’t really matter). The fonts will be downloaded in a zip format. Install and check the name of the font in the font file. In my case, it is “FiraCode Nerd Font”. Now we can go to Terminal settings by pressing Ctrl+Shift+, which will open the settings in JSON format, and add this to the &quot;profiles&quot;: &quot;defaults&quot;: key: &quot;font&quot;: { &quot;face&quot;: &quot;FiraCode Nerd Font&quot; } This is the place where we can adjust the size and style of the font if desired, e.g &quot;size&quot;: 10. Save and Terminal refreshes, now using the installed NerdFont. Shell-independent installation in Windows From this guide. First, we need to install oh-my-posh. We can do this using winget, the package manager CLI in Windows: winget install JanDeDobbeleer.OhMyPosh Now we will have the oh-my-posh.exe application which we can use to customize our prompt. For WSL, this will be oh-my-posh-wsl instead. Themes are present at the location ~\\AppData\\Local\\Programs\\oh-my-posh\\themes. We can list all the theme names: ls ~\\AppData\\Local\\Programs\\oh-my-posh\\themes\\ which are just JSON files with the name format *.omp.json. To actually view the themes in action, however, we can run the following command: Get-ChildItem -Path &quot;~\\AppData\\Local\\Programs\\oh-my-posh\\themes\\*&quot; -Include &#39;*.omp.json&#39; | Sort-Object Name | ForEach-Object -Process { $esc = [char]27 Write-Host &quot;&quot; Write-Host &quot;$esc[1m$($_.BaseName)$esc[0m&quot; Write-Host &quot;&quot; oh-my-posh --config $($_.FullName) --pwd $PWD Write-Host &quot;&quot; } which basically loops through all the JSON files in the folder and prints a custom prompt for each. To actually change the prompt, we can run oh-my-posh --init --shell pwsh --config ~/AppData/Local/Programs/oh-my-posh/themes/jandedobbeleer.omp.json | Invoke-Expression in Powershell, or eval &quot;$(oh-my-posh-wsl --init --shell bash --config $USERPROFILE/AppData/Local/Programs/oh-my-posh/themes/jandedobbeleer.omp.json)&quot; on bash in WSL.2 To make changes permanent, we need to add this command to the profile of the respective shells ($profile for Powershell and .bashrc for bash). Remarks Even though it seems like a PITA3 to write such a complicated path again and again (especially in WSL), once we’ve written it, all we have to do is modify the name of the theme (here jandedobbeleer) and not touch the path at all. However, if we are to modify these themes to our liking, it is wise to copy the JSON files to another location and make necessary changes, and then make the shell profile point to that location. Only for Powershell To start with, we run: Install-Module oh-my-posh -Scope CurrentUser in Powershell. This installs the oh-my-posh module for the current user (admin privileges not required?). For instance, it marks the root folder of this Jekyll website with a little ruby icon (Jekyll uses Ruby and the root folder has a Gemfile) or a Python symbol when python files are present. &#8617; The environment variable $USERPROFILE does not exist by default. It has to be forwarded from Windows to WSL via the WSLENV variable: setx WSLENV USERPROFILE/up and after a session restart, the Windows environment variable %USERPROFILE% containing the path to the user profile is available at $USERPROFILE in WSL (translated to a Linux-style path, the /p switch does this). (Source) &#8617; Pain-In-The-Ass. &#8617;","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="ProgBlog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">ProgBlog</a>

    <script>
      $(document).ready(function() {
      $('#close-btn').click(function() {
        $('#search-overlay').fadeOut();
        $('#search-btn').show();
      });
      $('#search-btn').click(function() {
        $(this).hide();
        $('#search-overlay').fadeIn();
      });
    });
    </script>
    
    <i id="search-btn" class="fa fa-search fa-2x"></i>
    <div id="search-overlay" class="block">
      <div class="centered">
        <!-- <div id='search-box'>
          <i id="close-btn" class="fa fa-times fa-2x"></i>
          <form action='/search' id='search-form' method='get' target='_top'>
            <input id='search-text' name='q' placeholder='Search' type='text' />
            <button id='search-button' type='submit'>                     
              <i id="search-btn" class="fa fa-search fa-2x"></i>
            </button>
          </form>
        </div> -->

        <!-- Html Elements for Search -->
        <div id="search-box">
          <i id="close-btn" class="fa fa-times fa-2x"></i>
          <input type="text" id="search-input" class="mousetrap" placeholder="Start searching...">
          <ul id="results-container"></ul>
        </div>
      </div>
    </div>
    <!-- Script pointing to search-script.js -->
    <script src="/js/search-script.js" type="text/javascript"></script>

    <!-- Configuration -->
    <script>
    var srch = SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('results-container'),
      json: '/search.json',
      searchResultTemplate: `
      <li>
        <div style="display:inline"><a href="{url}" title="{desc}">{title}</a></div>
        <div style="width:20%; float:right; border-left:2px solid #777"><span style="padding-left: 5px; opacity:0.75">{category}</span></div>
      </li>
      `
    })
    </script>

    <!-- Custom keybind to search -->
    <script>
      function showSearch() {
        if($('#close-btn').is(":hidden")) {
          $('#search-btn').click();
          $('#search-input').focus();
        }
      }
      function hideSearch() {
        if($('#search-btn').is(":hidden")) {
          $('#close-btn').click();
        }
      }
      Mousetrap.bind(['command+shift+f', 'ctrl+shift+f'], showSearch);
      Mousetrap.bind(['escape'], hideSearch);
    </script>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Customizing the Terminal Prompt with oh-my-posh</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-10-22T16:00:00+05:30" itemprop="datePublished">Oct 22, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>The module <strong>oh-my-posh</strong> is the Windows equivalent of <strong>oh-my-zsh</strong> for Linux. It can help create pretty prompts which may provide visual aids with <em>git</em> (among other things?<sup id="fnref:obs1" role="doc-noteref"><a href="#fn:obs1" class="footnote" rel="footnote">1</a></sup>). I stumbled upon this idea on <a href="https://zimmergren.net/making-windows-terminal-look-awesome-with-oh-my-posh/">this blog</a>, but really, it’s a very commonly used module. I’m going to use the <strong>Windows Terminal</strong>.</p>

<ul id="markdown-toc">
  <li><a href="#installing-a-nerdfont" id="markdown-toc-installing-a-nerdfont">Installing a NerdFont</a></li>
  <li><a href="#shell-independent-installation-in-windows" id="markdown-toc-shell-independent-installation-in-windows">Shell-independent installation in Windows</a>    <ul>
      <li><a href="#remarks" id="markdown-toc-remarks">Remarks</a></li>
    </ul>
  </li>
  <li><a href="#only-for-powershell" id="markdown-toc-only-for-powershell">Only for Powershell</a></li>
</ul>

<h3 id="installing-a-nerdfont">Installing a NerdFont</h3>

<p><strong>oh-my-posh</strong> uses glyphs that are not present in standard fonts. To get them, we need to install one of many <em>NerdFonts</em> from the <a href="https://www.nerdfonts.com/font-downloads">website</a>. <strong>Windows Terminal</strong> by default uses <em>Cascadia</em> fonts.  I prefer to use <em>Fira Code</em> instead. So we can just search for <em>Fira Code</em> in the website (or download any font - doesn’t really matter). The fonts will be downloaded in a <em>zip</em> format.</p>

<p><em>Install</em> and check the name of the font in the font file. In my case, it is “FiraCode Nerd Font”. Now we can go to Terminal settings by pressing <code class="language-plaintext highlighter-rouge">Ctrl+Shift+,</code> which will open the settings in JSON format, and add this to the <code class="language-plaintext highlighter-rouge">"profiles": "defaults":</code> key:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"font": 
            {
                "face": "FiraCode Nerd Font"
            }
</code></pre></div></div>
<p>This is the place where we can adjust the size and style of the font if desired, e.g <code class="language-plaintext highlighter-rouge">"size": 10</code>. Save and Terminal refreshes, now using the installed NerdFont.</p>

<h3 id="shell-independent-installation-in-windows">Shell-independent installation in Windows</h3>

<p>From <a href="https://ohmyposh.dev/docs/windows">this guide</a>. First, we need to install <strong>oh-my-posh</strong>. We can do this using <strong>winget</strong>, the package manager CLI in Windows:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>winget install JanDeDobbeleer.OhMyPosh
</code></pre></div></div>
<p>Now we will have the <code class="language-plaintext highlighter-rouge">oh-my-posh.exe</code> application which we can use to customize our prompt. For WSL, this will be <code class="language-plaintext highlighter-rouge">oh-my-posh-wsl</code> instead. Themes are present at the location <em>~\AppData\Local\Programs\oh-my-posh\themes</em>. We can list all the theme names:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ls ~\AppData\Local\Programs\oh-my-posh\themes\
</code></pre></div></div>
<p>which are just JSON files with the name format <em>*.omp.json</em>. To actually <em>view</em> the themes in action, however, we can run the following command:</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Get-ChildItem</span><span class="w"> </span><span class="nt">-Path</span><span class="w"> </span><span class="s2">"~\AppData\Local\Programs\oh-my-posh\themes\*"</span><span class="w"> </span><span class="nt">-Include</span><span class="w"> </span><span class="s1">'*.omp.json'</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Sort-Object</span><span class="w"> </span><span class="nx">Name</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ForEach-Object</span><span class="w"> </span><span class="nt">-Process</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nv">$esc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">char</span><span class="p">]</span><span class="mi">27</span><span class="w">
    </span><span class="n">Write-Host</span><span class="w"> </span><span class="s2">""</span><span class="w">
    </span><span class="n">Write-Host</span><span class="w"> </span><span class="s2">"</span><span class="nv">$esc</span><span class="s2">[1m</span><span class="si">$(</span><span class="bp">$_</span><span class="o">.</span><span class="nf">BaseName</span><span class="si">)</span><span class="nv">$esc</span><span class="s2">[0m"</span><span class="w">
    </span><span class="n">Write-Host</span><span class="w"> </span><span class="s2">""</span><span class="w">
    </span><span class="n">oh-my-posh</span><span class="w"> </span><span class="nt">--config</span><span class="w"> </span><span class="err">$</span><span class="p">(</span><span class="bp">$_</span><span class="o">.</span><span class="nf">FullName</span><span class="p">)</span><span class="w"> </span><span class="nt">--pwd</span><span class="w"> </span><span class="bp">$PWD</span><span class="w">
    </span><span class="n">Write-Host</span><span class="w"> </span><span class="s2">""</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>
<p>which basically loops through all the JSON files in the folder and prints a custom prompt for each. To actually change the prompt, we can run</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">oh-my-posh</span><span class="w"> </span><span class="nt">--init</span><span class="w"> </span><span class="nt">--shell</span><span class="w"> </span><span class="nx">pwsh</span><span class="w"> </span><span class="nt">--config</span><span class="w"> </span><span class="nx">~/AppData/Local/Programs/oh-my-posh/themes/jandedobbeleer.omp.json</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Invoke-Expression</span><span class="w">
</span></code></pre></div></div>
<p>in Powershell, or</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">eval</span> <span class="s2">"</span><span class="si">$(</span>oh-my-posh-wsl <span class="nt">--init</span> <span class="nt">--shell</span> bash <span class="nt">--config</span> <span class="nv">$USERPROFILE</span>/AppData/Local/Programs/oh-my-posh/themes/jandedobbeleer.omp.json<span class="si">)</span><span class="s2">"</span>
</code></pre></div></div>
<p>on <em>bash</em> in WSL.<sup id="fnref:envvarnote" role="doc-noteref"><a href="#fn:envvarnote" class="footnote" rel="footnote">2</a></sup></p>

<p>To make changes permanent, we need to add this command to the profile of the respective shells (<em>$profile</em> for Powershell and <em>.bashrc</em> for bash).</p>

<h4 id="remarks">Remarks</h4>

<p>Even though it seems like a PITA<sup id="fnref:pita" role="doc-noteref"><a href="#fn:pita" class="footnote" rel="footnote">3</a></sup> to write such a complicated path again and again (especially in WSL), once we’ve written it, all we have to do is modify the name of the theme (here <code class="language-plaintext highlighter-rouge">jandedobbeleer</code>) and not touch the path at all. However, if we are to <a href="https://ohmyposh.dev/docs/configure">modify these themes</a> to our liking, it is wise to copy the JSON files to another location and make necessary changes, and <em>then</em> make the <em>shell profile</em> point to that location.</p>

<h3 id="only-for-powershell">Only for Powershell</h3>

<p>To start with, we run:</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Install-Module</span><span class="w"> </span><span class="nx">oh-my-posh</span><span class="w"> </span><span class="nt">-Scope</span><span class="w"> </span><span class="nx">CurrentUser</span><span class="w">
</span></code></pre></div></div>
<p>in Powershell. This installs the <strong>oh-my-posh</strong> module for the current user (admin privileges not required?).</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:obs1" role="doc-endnote">
      <p>For instance, it marks the root folder of this Jekyll website with a little ruby icon (Jekyll uses Ruby and the root folder has a <em>Gemfile</em>) or a Python symbol when python files are present. <a href="#fnref:obs1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:envvarnote" role="doc-endnote">
      <p>The environment variable <code class="language-plaintext highlighter-rouge">$USERPROFILE</code> does not exist by default. It has to be <em>forwarded</em> from Windows to WSL via the <code class="language-plaintext highlighter-rouge">WSLENV</code> variable:</p>
      <div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">setx</span><span class="w"> </span><span class="nx">WSLENV</span><span class="w"> </span><span class="nx">USERPROFILE/up</span><span class="w">
</span></code></pre></div>      </div>
      <p>and after a session restart, the Windows environment variable <code class="language-plaintext highlighter-rouge">%USERPROFILE%</code> containing the path to the user profile is available at <code class="language-plaintext highlighter-rouge">$USERPROFILE</code> in WSL (translated to a Linux-style path, the <code class="language-plaintext highlighter-rouge">/p</code> switch does this). (<a href="https://superuser.com/a/1546688/1171201">Source</a>) <a href="#fnref:envvarnote" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:pita" role="doc-endnote">
      <p>Pain-In-The-Ass. <a href="#fnref:pita" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/tweaks/2021/10/22/change-term-prompt-omp.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">ProgBlog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">ProgBlog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/amzon-ex"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">amzon-ex</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>A blog documenting progress</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
