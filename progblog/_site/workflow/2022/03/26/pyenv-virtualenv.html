<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="http://code.jquery.com/jquery-3.2.1.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/mousetrap/1.4.6/mousetrap.min.js"></script>
  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="/progblog/css/searchoverlay.css" rel="stylesheet"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Python virtual environments with pyenv | ProgBlog</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Python virtual environments with pyenv" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Virtual environments isolate a set of executables, libraries and related files from another such set. From the python docs: A virtual environment is a Python environment such that the Python interpreter, libraries and scripts installed into it are isolated from those installed in other virtual environments, and (by default) any libraries installed in a “system” Python, i.e., one which is installed as part of your operating system. There are many options to do this: venv (comes installed by default with Python 3.3+), virtualenv, conda, poetry and so on… For people like us who use these languages mostly for scientific work, conda is a great option (and for other applications too - it handles dependency management well and has its own package manager conda), but it irks me to great measure because to install conda you’d have to install a python version (the base version of conda) again (?!) and the install size, even for miniconda, is ~400MB. It is however a good option if that’s the first python installation one starts with - I happened to have a working python installation (v3.9.7 on Ubuntu 21.10 on WSL) with many packages and I was unwilling to get rid of it and consequently break many applications. Also, many applications demand a different python version altogether. If one does not use conda, separate python versions must be installed which can also break functionality if the path to the appropriate executable is not set in PATH and scripts do not properly select the right version. So this demands proper management. This is what we achieve with pyenv. pyenv helps manage various python installations on the system easily and also provides the plugin pyenv-virtualenv (installed separately, based on venv/virtualenv: more on this). Installation To start with, we configure a proper build environment for building Python distributions with pyenv on-the-fly: sudo apt-get update; \ sudo apt-get install make build-essential libssl-dev zlib1g-dev \ libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \ libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev Some of these packages would probably already be installed, but be prepared to install a bulk of packages. For me the download size was ~100MB and installation size ~500MB. 1 Once this is done, we install pyenv via a Github checkout (of course, git needs to be installed). To do so, we first clone the repo: git clone https://github.com/pyenv/pyenv.git ~/.pyenv where the location has been set as ~/.pyenv/. This can be changed. Next, we optionally try to compile a dynamic Bash extension (without this step, pyenv works just fine, this should just speed up pyenv): cd ~/.pyenv &amp;&amp; src/configure &amp;&amp; make -C src Next, we configure the shell’s environment to work with pyenv. For bash on Ubuntu with a .profile file that sources .bashrc, sed -Ei -e &#39;/^([^#]|$)/ {a \ export PYENV_ROOT=&quot;$HOME/.pyenv&quot; a \ export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; a \ &#39; -e &#39;:a&#39; -e &#39;$!{n;ba};}&#39; ~/.profile This puts the two export lines at the beginning (which is why we do all the gymnastics with sed) of .profile to Create the variable $PYENV_ROOT which stores the path to the folder we cloned the repo to, and Add this variable to (the beginning of) $PATH. echo &#39;eval &quot;$(pyenv init --path)&quot;&#39; &gt;&gt;~/.profile This puts the pyenv shims into $PATH. The shims redirect calls to the python executable to the right one. Details on the working here. echo &#39;eval &quot;$(pyenv init -)&quot;&#39; &gt;&gt; ~/.bashrc and this modifies .bashrc. For other setups, see here. Finally, we restart the shell - and we’re done installing pyenv! Next, we install pyenv-virtualenv. This simply requires checking out the repo to the .pyenv/plugins/ directory: git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv and we then run exec &lt;shell&gt; (in our case, &lt;shell&gt; is just bash) to restart the shell. If installed with this method, upgrading is super simple - we just go the .pyenv directory and pull from the repo. cd $(pyenv root) git pull and a similar procedure follows for pyenv-virtualenv. Usage When using pyenv, we have a system version of python that is present by default (python was installed by default, of course). We can install more versions by running pyenv install &lt;version&gt; where we &lt;version&gt; may be replaced by 3.8.1, for instance. We can list all available versions by typing pyenv install --list and choose the appropriate one. After installation, this goes under .pyenv/versions/{version}/ and all packages/virtual-environments concerning this version go under this directory. We can list the currently installed versions by pyenv versions The currently active version is marked by an asterisk (*). This can also be checked by running pyenv version instead. The output of the command will depend upon the current session or the current location. This is how pyenv chooses the python version (from the docs): The PYENV_VERSION environment variable (if specified). You can use the pyenv shell command to set this environment variable in your current shell session. The application-specific .python-version file in the current directory (if present). You can modify the current directory’s .python-version file with the pyenv local command. The first .python-version file found (if any) by searching each parent directory, until reaching the root of your filesystem. The global $(pyenv root)/version file. You can modify this file using the pyenv global command. If the global version file is not present, pyenv assumes you want to use the system Python. (In other words, whatever version would run if pyenv weren’t in your PATH.) In other words, there are two ways to specify a python version to use: Change the version being used for the current session by running pyenv shell &lt;version&gt;. Running pyenv shell or pyenv version would now show &lt;version&gt; as output. For this session, until changed, this version will be used for running python scripts. We can run pyenv shell --unset to revert to the shell being originally used before any such commands were executed. This choice has the higest precedence. Create a .python-version file by running pyenv local &lt;version&gt; in a project directory. Whenever scripts are run from this directory, or any subdirectories, the chosen version will always be used, considering no shell version has been configured for the session. One can set multiple versions in decreasing order of precedence by running pyenv local &lt;version-1&gt; &lt;version-2&gt; ... in a directory. Again, running pyenv local or pyenv version would now show the active versions as output. To unset this file/config, run pyenv local --unset. To uninstall a python version, we can either run pyenv uninstall &lt;version&gt; or remove the entire {version}/ directory in .pyenv/versions/. To create virtual environments (our original concern!), we run the command pyenv virtualenv &lt;version&gt; &lt;env-name&gt; i.e. we select a &lt;version&gt; and specify the name &lt;env-name&gt; of the virtual environment we want to create. We can omit &lt;version&gt;: in that case, the version currently set will be used to create the virtual environment, as determined by our configuration. The packages installed under this environment will be listed under the directory .pyenv/versions/{version}/envs/{env-name}. To activate this environment, we run pyenv activate &lt;env-name&gt; and pyenv deactivate to - well, deactivate the environment. To list created virtual environments, we run pyenv virtualenvs. It is possible to specify a virtual environment in a local .python-version file by running pyenv local &lt;env-name&gt; As mentioned before, we can list multiple python versions, environments etc. separated by spaces. To remove an environment altogether, we can run pyenv virtualenv-delete &lt;env-name&gt; or just delete the {env-name} directory in .pyenv/versions/{version}/envs/. After activating, we might want to install necessary packages. One could do this using a requirements text file which lists specific versions of packages (perhaps a natural use-case in virtual environments), passed to pip: pip install -r requirements.txt It could be helpful to use a --no-cache-dir option if pip uses cached versions which do not match the required version.2 Installing ipython kernel Finally, we could install an ipython kernel for a virtual environment, if we use jupyter notebook installed for the system version. Installing multiple jupyter instances may in general not make sense (?). So we run pyenv activate &lt;env-name&gt; pip install ipykernel ipython_genutils Note: Depending upon the project and/or the python version, a specific version of ipykernel might be required. By installing ipython_genutils for the environment we can get away without installing ipython itself, since it will be installed for the system version. After the installation, we may run python -m ipykernel install --user --name=&lt;env-kernel-name&gt; where we type in a name for this kernel. It need not be identical to &lt;env-name&gt;. Now when we fire Jupyter Lab/notebook, this kernel should be available. We wouldn’t need to activate the virtual environment for this purpose. Of course, one can ask here if this defeats the purpose of not installing conda - but it is probably not necessary to install all of these. It is suggested by the devs - the question of potential failure would probably need to be answered on a case-by-case basis. In any case, this step can probably be optimized. TO BE INVESTIGATED &#8617; This may likely happen when the unlisted dependencies of the packages listed are installed from cache. However, using --no-cache-dir might significantly increase install times. Some details here. &#8617;" />
<meta property="og:description" content="Virtual environments isolate a set of executables, libraries and related files from another such set. From the python docs: A virtual environment is a Python environment such that the Python interpreter, libraries and scripts installed into it are isolated from those installed in other virtual environments, and (by default) any libraries installed in a “system” Python, i.e., one which is installed as part of your operating system. There are many options to do this: venv (comes installed by default with Python 3.3+), virtualenv, conda, poetry and so on… For people like us who use these languages mostly for scientific work, conda is a great option (and for other applications too - it handles dependency management well and has its own package manager conda), but it irks me to great measure because to install conda you’d have to install a python version (the base version of conda) again (?!) and the install size, even for miniconda, is ~400MB. It is however a good option if that’s the first python installation one starts with - I happened to have a working python installation (v3.9.7 on Ubuntu 21.10 on WSL) with many packages and I was unwilling to get rid of it and consequently break many applications. Also, many applications demand a different python version altogether. If one does not use conda, separate python versions must be installed which can also break functionality if the path to the appropriate executable is not set in PATH and scripts do not properly select the right version. So this demands proper management. This is what we achieve with pyenv. pyenv helps manage various python installations on the system easily and also provides the plugin pyenv-virtualenv (installed separately, based on venv/virtualenv: more on this). Installation To start with, we configure a proper build environment for building Python distributions with pyenv on-the-fly: sudo apt-get update; \ sudo apt-get install make build-essential libssl-dev zlib1g-dev \ libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \ libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev Some of these packages would probably already be installed, but be prepared to install a bulk of packages. For me the download size was ~100MB and installation size ~500MB. 1 Once this is done, we install pyenv via a Github checkout (of course, git needs to be installed). To do so, we first clone the repo: git clone https://github.com/pyenv/pyenv.git ~/.pyenv where the location has been set as ~/.pyenv/. This can be changed. Next, we optionally try to compile a dynamic Bash extension (without this step, pyenv works just fine, this should just speed up pyenv): cd ~/.pyenv &amp;&amp; src/configure &amp;&amp; make -C src Next, we configure the shell’s environment to work with pyenv. For bash on Ubuntu with a .profile file that sources .bashrc, sed -Ei -e &#39;/^([^#]|$)/ {a \ export PYENV_ROOT=&quot;$HOME/.pyenv&quot; a \ export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; a \ &#39; -e &#39;:a&#39; -e &#39;$!{n;ba};}&#39; ~/.profile This puts the two export lines at the beginning (which is why we do all the gymnastics with sed) of .profile to Create the variable $PYENV_ROOT which stores the path to the folder we cloned the repo to, and Add this variable to (the beginning of) $PATH. echo &#39;eval &quot;$(pyenv init --path)&quot;&#39; &gt;&gt;~/.profile This puts the pyenv shims into $PATH. The shims redirect calls to the python executable to the right one. Details on the working here. echo &#39;eval &quot;$(pyenv init -)&quot;&#39; &gt;&gt; ~/.bashrc and this modifies .bashrc. For other setups, see here. Finally, we restart the shell - and we’re done installing pyenv! Next, we install pyenv-virtualenv. This simply requires checking out the repo to the .pyenv/plugins/ directory: git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv and we then run exec &lt;shell&gt; (in our case, &lt;shell&gt; is just bash) to restart the shell. If installed with this method, upgrading is super simple - we just go the .pyenv directory and pull from the repo. cd $(pyenv root) git pull and a similar procedure follows for pyenv-virtualenv. Usage When using pyenv, we have a system version of python that is present by default (python was installed by default, of course). We can install more versions by running pyenv install &lt;version&gt; where we &lt;version&gt; may be replaced by 3.8.1, for instance. We can list all available versions by typing pyenv install --list and choose the appropriate one. After installation, this goes under .pyenv/versions/{version}/ and all packages/virtual-environments concerning this version go under this directory. We can list the currently installed versions by pyenv versions The currently active version is marked by an asterisk (*). This can also be checked by running pyenv version instead. The output of the command will depend upon the current session or the current location. This is how pyenv chooses the python version (from the docs): The PYENV_VERSION environment variable (if specified). You can use the pyenv shell command to set this environment variable in your current shell session. The application-specific .python-version file in the current directory (if present). You can modify the current directory’s .python-version file with the pyenv local command. The first .python-version file found (if any) by searching each parent directory, until reaching the root of your filesystem. The global $(pyenv root)/version file. You can modify this file using the pyenv global command. If the global version file is not present, pyenv assumes you want to use the system Python. (In other words, whatever version would run if pyenv weren’t in your PATH.) In other words, there are two ways to specify a python version to use: Change the version being used for the current session by running pyenv shell &lt;version&gt;. Running pyenv shell or pyenv version would now show &lt;version&gt; as output. For this session, until changed, this version will be used for running python scripts. We can run pyenv shell --unset to revert to the shell being originally used before any such commands were executed. This choice has the higest precedence. Create a .python-version file by running pyenv local &lt;version&gt; in a project directory. Whenever scripts are run from this directory, or any subdirectories, the chosen version will always be used, considering no shell version has been configured for the session. One can set multiple versions in decreasing order of precedence by running pyenv local &lt;version-1&gt; &lt;version-2&gt; ... in a directory. Again, running pyenv local or pyenv version would now show the active versions as output. To unset this file/config, run pyenv local --unset. To uninstall a python version, we can either run pyenv uninstall &lt;version&gt; or remove the entire {version}/ directory in .pyenv/versions/. To create virtual environments (our original concern!), we run the command pyenv virtualenv &lt;version&gt; &lt;env-name&gt; i.e. we select a &lt;version&gt; and specify the name &lt;env-name&gt; of the virtual environment we want to create. We can omit &lt;version&gt;: in that case, the version currently set will be used to create the virtual environment, as determined by our configuration. The packages installed under this environment will be listed under the directory .pyenv/versions/{version}/envs/{env-name}. To activate this environment, we run pyenv activate &lt;env-name&gt; and pyenv deactivate to - well, deactivate the environment. To list created virtual environments, we run pyenv virtualenvs. It is possible to specify a virtual environment in a local .python-version file by running pyenv local &lt;env-name&gt; As mentioned before, we can list multiple python versions, environments etc. separated by spaces. To remove an environment altogether, we can run pyenv virtualenv-delete &lt;env-name&gt; or just delete the {env-name} directory in .pyenv/versions/{version}/envs/. After activating, we might want to install necessary packages. One could do this using a requirements text file which lists specific versions of packages (perhaps a natural use-case in virtual environments), passed to pip: pip install -r requirements.txt It could be helpful to use a --no-cache-dir option if pip uses cached versions which do not match the required version.2 Installing ipython kernel Finally, we could install an ipython kernel for a virtual environment, if we use jupyter notebook installed for the system version. Installing multiple jupyter instances may in general not make sense (?). So we run pyenv activate &lt;env-name&gt; pip install ipykernel ipython_genutils Note: Depending upon the project and/or the python version, a specific version of ipykernel might be required. By installing ipython_genutils for the environment we can get away without installing ipython itself, since it will be installed for the system version. After the installation, we may run python -m ipykernel install --user --name=&lt;env-kernel-name&gt; where we type in a name for this kernel. It need not be identical to &lt;env-name&gt;. Now when we fire Jupyter Lab/notebook, this kernel should be available. We wouldn’t need to activate the virtual environment for this purpose. Of course, one can ask here if this defeats the purpose of not installing conda - but it is probably not necessary to install all of these. It is suggested by the devs - the question of potential failure would probably need to be answered on a case-by-case basis. In any case, this step can probably be optimized. TO BE INVESTIGATED &#8617; This may likely happen when the unlisted dependencies of the packages listed are installed from cache. However, using --no-cache-dir might significantly increase install times. Some details here. &#8617;" />
<link rel="canonical" href="http://localhost:4000/progblog/workflow/2022/03/26/pyenv-virtualenv.html" />
<meta property="og:url" content="http://localhost:4000/progblog/workflow/2022/03/26/pyenv-virtualenv.html" />
<meta property="og:site_name" content="ProgBlog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-03-26T17:55:00+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Python virtual environments with pyenv" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"http://localhost:4000/progblog/workflow/2022/03/26/pyenv-virtualenv.html","headline":"Python virtual environments with pyenv","dateModified":"2022-03-26T17:55:00+05:30","datePublished":"2022-03-26T17:55:00+05:30","description":"Virtual environments isolate a set of executables, libraries and related files from another such set. From the python docs: A virtual environment is a Python environment such that the Python interpreter, libraries and scripts installed into it are isolated from those installed in other virtual environments, and (by default) any libraries installed in a “system” Python, i.e., one which is installed as part of your operating system. There are many options to do this: venv (comes installed by default with Python 3.3+), virtualenv, conda, poetry and so on… For people like us who use these languages mostly for scientific work, conda is a great option (and for other applications too - it handles dependency management well and has its own package manager conda), but it irks me to great measure because to install conda you’d have to install a python version (the base version of conda) again (?!) and the install size, even for miniconda, is ~400MB. It is however a good option if that’s the first python installation one starts with - I happened to have a working python installation (v3.9.7 on Ubuntu 21.10 on WSL) with many packages and I was unwilling to get rid of it and consequently break many applications. Also, many applications demand a different python version altogether. If one does not use conda, separate python versions must be installed which can also break functionality if the path to the appropriate executable is not set in PATH and scripts do not properly select the right version. So this demands proper management. This is what we achieve with pyenv. pyenv helps manage various python installations on the system easily and also provides the plugin pyenv-virtualenv (installed separately, based on venv/virtualenv: more on this). Installation To start with, we configure a proper build environment for building Python distributions with pyenv on-the-fly: sudo apt-get update; \\ sudo apt-get install make build-essential libssl-dev zlib1g-dev \\ libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \\ libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev Some of these packages would probably already be installed, but be prepared to install a bulk of packages. For me the download size was ~100MB and installation size ~500MB. 1 Once this is done, we install pyenv via a Github checkout (of course, git needs to be installed). To do so, we first clone the repo: git clone https://github.com/pyenv/pyenv.git ~/.pyenv where the location has been set as ~/.pyenv/. This can be changed. Next, we optionally try to compile a dynamic Bash extension (without this step, pyenv works just fine, this should just speed up pyenv): cd ~/.pyenv &amp;&amp; src/configure &amp;&amp; make -C src Next, we configure the shell’s environment to work with pyenv. For bash on Ubuntu with a .profile file that sources .bashrc, sed -Ei -e &#39;/^([^#]|$)/ {a \\ export PYENV_ROOT=&quot;$HOME/.pyenv&quot; a \\ export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot; a \\ &#39; -e &#39;:a&#39; -e &#39;$!{n;ba};}&#39; ~/.profile This puts the two export lines at the beginning (which is why we do all the gymnastics with sed) of .profile to Create the variable $PYENV_ROOT which stores the path to the folder we cloned the repo to, and Add this variable to (the beginning of) $PATH. echo &#39;eval &quot;$(pyenv init --path)&quot;&#39; &gt;&gt;~/.profile This puts the pyenv shims into $PATH. The shims redirect calls to the python executable to the right one. Details on the working here. echo &#39;eval &quot;$(pyenv init -)&quot;&#39; &gt;&gt; ~/.bashrc and this modifies .bashrc. For other setups, see here. Finally, we restart the shell - and we’re done installing pyenv! Next, we install pyenv-virtualenv. This simply requires checking out the repo to the .pyenv/plugins/ directory: git clone https://github.com/pyenv/pyenv-virtualenv.git $(pyenv root)/plugins/pyenv-virtualenv and we then run exec &lt;shell&gt; (in our case, &lt;shell&gt; is just bash) to restart the shell. If installed with this method, upgrading is super simple - we just go the .pyenv directory and pull from the repo. cd $(pyenv root) git pull and a similar procedure follows for pyenv-virtualenv. Usage When using pyenv, we have a system version of python that is present by default (python was installed by default, of course). We can install more versions by running pyenv install &lt;version&gt; where we &lt;version&gt; may be replaced by 3.8.1, for instance. We can list all available versions by typing pyenv install --list and choose the appropriate one. After installation, this goes under .pyenv/versions/{version}/ and all packages/virtual-environments concerning this version go under this directory. We can list the currently installed versions by pyenv versions The currently active version is marked by an asterisk (*). This can also be checked by running pyenv version instead. The output of the command will depend upon the current session or the current location. This is how pyenv chooses the python version (from the docs): The PYENV_VERSION environment variable (if specified). You can use the pyenv shell command to set this environment variable in your current shell session. The application-specific .python-version file in the current directory (if present). You can modify the current directory’s .python-version file with the pyenv local command. The first .python-version file found (if any) by searching each parent directory, until reaching the root of your filesystem. The global $(pyenv root)/version file. You can modify this file using the pyenv global command. If the global version file is not present, pyenv assumes you want to use the system Python. (In other words, whatever version would run if pyenv weren’t in your PATH.) In other words, there are two ways to specify a python version to use: Change the version being used for the current session by running pyenv shell &lt;version&gt;. Running pyenv shell or pyenv version would now show &lt;version&gt; as output. For this session, until changed, this version will be used for running python scripts. We can run pyenv shell --unset to revert to the shell being originally used before any such commands were executed. This choice has the higest precedence. Create a .python-version file by running pyenv local &lt;version&gt; in a project directory. Whenever scripts are run from this directory, or any subdirectories, the chosen version will always be used, considering no shell version has been configured for the session. One can set multiple versions in decreasing order of precedence by running pyenv local &lt;version-1&gt; &lt;version-2&gt; ... in a directory. Again, running pyenv local or pyenv version would now show the active versions as output. To unset this file/config, run pyenv local --unset. To uninstall a python version, we can either run pyenv uninstall &lt;version&gt; or remove the entire {version}/ directory in .pyenv/versions/. To create virtual environments (our original concern!), we run the command pyenv virtualenv &lt;version&gt; &lt;env-name&gt; i.e. we select a &lt;version&gt; and specify the name &lt;env-name&gt; of the virtual environment we want to create. We can omit &lt;version&gt;: in that case, the version currently set will be used to create the virtual environment, as determined by our configuration. The packages installed under this environment will be listed under the directory .pyenv/versions/{version}/envs/{env-name}. To activate this environment, we run pyenv activate &lt;env-name&gt; and pyenv deactivate to - well, deactivate the environment. To list created virtual environments, we run pyenv virtualenvs. It is possible to specify a virtual environment in a local .python-version file by running pyenv local &lt;env-name&gt; As mentioned before, we can list multiple python versions, environments etc. separated by spaces. To remove an environment altogether, we can run pyenv virtualenv-delete &lt;env-name&gt; or just delete the {env-name} directory in .pyenv/versions/{version}/envs/. After activating, we might want to install necessary packages. One could do this using a requirements text file which lists specific versions of packages (perhaps a natural use-case in virtual environments), passed to pip: pip install -r requirements.txt It could be helpful to use a --no-cache-dir option if pip uses cached versions which do not match the required version.2 Installing ipython kernel Finally, we could install an ipython kernel for a virtual environment, if we use jupyter notebook installed for the system version. Installing multiple jupyter instances may in general not make sense (?). So we run pyenv activate &lt;env-name&gt; pip install ipykernel ipython_genutils Note: Depending upon the project and/or the python version, a specific version of ipykernel might be required. By installing ipython_genutils for the environment we can get away without installing ipython itself, since it will be installed for the system version. After the installation, we may run python -m ipykernel install --user --name=&lt;env-kernel-name&gt; where we type in a name for this kernel. It need not be identical to &lt;env-name&gt;. Now when we fire Jupyter Lab/notebook, this kernel should be available. We wouldn’t need to activate the virtual environment for this purpose. Of course, one can ask here if this defeats the purpose of not installing conda - but it is probably not necessary to install all of these. It is suggested by the devs - the question of potential failure would probably need to be answered on a case-by-case basis. In any case, this step can probably be optimized. TO BE INVESTIGATED &#8617; This may likely happen when the unlisted dependencies of the packages listed are installed from cache. However, using --no-cache-dir might significantly increase install times. Some details here. &#8617;","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/progblog/workflow/2022/03/26/pyenv-virtualenv.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/progblog/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/progblog/feed.xml" title="ProgBlog" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/progblog/">ProgBlog</a>

    <script>
      $(document).ready(function() {
      $('#close-btn').click(function() {
        $('#search-overlay').fadeOut();
        $('#search-btn').show();
      });
      $('#search-btn').click(function() {
        $(this).hide();
        $('#search-overlay').fadeIn();
      });
    });
    </script>
    
    <i id="search-btn" class="fa fa-search fa-2x"></i>
    <div id="search-overlay" class="block">
      <div class="centered">
        <!-- <div id='search-box'>
          <i id="close-btn" class="fa fa-times fa-2x"></i>
          <form action='/search' id='search-form' method='get' target='_top'>
            <input id='search-text' name='q' placeholder='Search' type='text' />
            <button id='search-button' type='submit'>                     
              <i id="search-btn" class="fa fa-search fa-2x"></i>
            </button>
          </form>
        </div> -->

        <!-- Html Elements for Search -->
        <div id="search-box">
          <i id="close-btn" class="fa fa-times fa-2x"></i>
          <input type="text" id="search-input" class="mousetrap" placeholder="Start searching...">
          <ul id="results-container"></ul>
        </div>
      </div>
    </div>
    <!-- Script pointing to search-script.js -->
    <script src="/progblog/js/search-script.js" type="text/javascript"></script>

    <!-- Configuration -->
    <script>
    var srch = SimpleJekyllSearch({
      searchInput: document.getElementById('search-input'),
      resultsContainer: document.getElementById('results-container'),
      json: '/progblog/search.json',
      searchResultTemplate: `
      <li>
        <div style="display:inline"><a href="{url}" title="{desc}">{title}</a></div>
        <div style="width:20%; float:right; border-left:2px solid #777"><span style="padding-left: 5px; opacity:0.75">{category}</span></div>
      </li>
      `
    })
    </script>

    <!-- Custom keybind to search -->
    <script>
      function showSearch() {
        if($('#close-btn').is(":hidden")) {
          $('#search-btn').click();
          $('#search-input').focus();
        }
      }
      function hideSearch() {
        if($('#search-btn').is(":hidden")) {
          $('#close-btn').click();
        }
      }
      Mousetrap.bind(['command+shift+f', 'ctrl+shift+f'], showSearch);
      Mousetrap.bind(['escape'], hideSearch);
    </script>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Python virtual environments with pyenv</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-03-26T17:55:00+05:30" itemprop="datePublished">Mar 26, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    
<p>Virtual environments isolate a set of executables, libraries and related files from another such set. From the <strong>python</strong> <a href="https://docs.python.org/3/library/venv.html">docs</a>:</p>
<blockquote>
  <p>A virtual environment is a Python environment such that the Python interpreter, libraries and scripts installed into it are isolated from those installed in other virtual environments, and (by default) any libraries installed in a “system” Python, i.e., one which is installed as part of your operating system.</p>
</blockquote>

<p>There are many options to do this: <strong>venv</strong> (comes installed by default with Python 3.3+), <strong>virtualenv</strong>, <strong>conda</strong>, <strong>poetry</strong> and so on… For people like us who use these languages mostly for scientific work, <strong>conda</strong> is a great option (and for other applications too - it handles dependency management well and has its own package manager <code class="language-plaintext highlighter-rouge">conda</code>), but it irks me to great measure because to install conda you’d have to install a <strong>python</strong> version (the <em>base</em> version of conda) again (?!) and the install size, even for <a href="https://docs.conda.io/en/latest/miniconda.html"><strong>miniconda</strong></a>, is ~400MB. It is however a good option if that’s the <em>first python installation one starts with</em> - I happened to have a working python installation (v3.9.7 on Ubuntu 21.10 on WSL) with many packages and I was unwilling to get rid of it and consequently break many applications.</p>

<p>Also, many applications demand a different python version altogether. If one does not use <strong>conda</strong>, separate python versions must be installed which can also break functionality if the path to the appropriate executable is not set in <code class="language-plaintext highlighter-rouge">PATH</code> and scripts do not properly select the right version. So this demands proper management. This is what we achieve with <a href="https://github.com/pyenv/pyenv"><strong>pyenv</strong></a>.</p>

<p><strong>pyenv</strong> helps manage various python installations on the system easily and also provides the plugin <a href="https://github.com/pyenv/pyenv-virtualenv"><strong>pyenv-virtualenv</strong></a> (installed separately, based on <strong>venv</strong>/<strong>virtualenv</strong>: <a href="https://github.com/pyenv/pyenv-virtualenv#virtualenv-and-venv">more on this</a>).</p>

<h3 id="installation">Installation</h3>

<p>To start with, we configure a <a href="https://github.com/pyenv/pyenv/wiki#suggested-build-environment">proper build environment</a> for building Python distributions with <strong>pyenv</strong> on-the-fly:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt-get update<span class="p">;</span> <span class="se">\</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>make build-essential libssl-dev zlib1g-dev <span class="se">\</span>
libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm <span class="se">\</span>
libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev
</code></pre></div></div>
<p>Some of these packages would probably already be installed, but be prepared to install a bulk of packages. For me the download size was ~100MB and installation size ~500MB. <sup id="fnref:sizeissue" role="doc-noteref"><a href="#fn:sizeissue" class="footnote" rel="footnote">1</a></sup></p>

<p>Once this is done, we install <strong>pyenv</strong> via a Github checkout (of course, <code class="language-plaintext highlighter-rouge">git</code> needs to be installed). To do so, we first clone the repo:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> git clone https://github.com/pyenv/pyenv.git ~/.pyenv
</code></pre></div></div>
<p>where the location has been set as <em>~/.pyenv/</em>. This can be changed. Next, we optionally <em>try</em> to compile a <em>dynamic Bash extension</em> (without this step, <strong>pyenv</strong> works just fine, this should just speed up <strong>pyenv</strong>):</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">cd</span> ~/.pyenv <span class="o">&amp;&amp;</span> src/configure <span class="o">&amp;&amp;</span> make <span class="nt">-C</span> src
</code></pre></div></div>
<p>Next, we configure the shell’s environment to work with <strong>pyenv</strong>. For bash on Ubuntu with a <em>.profile</em> file that sources <em>.bashrc</em>,</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sed</span> <span class="nt">-Ei</span> <span class="nt">-e</span> <span class="s1">'/^([^#]|$)/ {a \
export PYENV_ROOT="$HOME/.pyenv"
a \
export PATH="$PYENV_ROOT/bin:$PATH"
a \
'</span> <span class="nt">-e</span> <span class="s1">':a'</span> <span class="nt">-e</span> <span class="s1">'$!{n;ba};}'</span> ~/.profile
</code></pre></div></div>
<p>This puts the two <code class="language-plaintext highlighter-rouge">export</code> lines at the beginning (which is why we do all the gymnastics with <code class="language-plaintext highlighter-rouge">sed</code>) of <em>.profile</em> to</p>
<ul>
  <li>Create the variable <em>$PYENV_ROOT</em> which stores the path to the folder we cloned the repo to, and</li>
  <li>Add this variable to (the beginning of) <em>$PATH</em>.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'eval "$(pyenv init --path)"'</span> <span class="o">&gt;&gt;</span>~/.profile
</code></pre></div>    </div>
    <p>This puts the pyenv <em>shims</em> into <em>$PATH</em>. The <em>shims</em> redirect calls to the python executable to the right one. Details on the working <a href="https://github.com/pyenv/pyenv#how-it-works">here</a>.</p>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'eval "$(pyenv init -)"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
</code></pre></div>    </div>
    <p>and this modifies <em>.bashrc</em>. For other setups, see <a href="https://github.com/pyenv/pyenv#basic-github-checkout">here</a>.</p>
  </li>
</ul>

<p>Finally, we restart the shell - and we’re done installing pyenv!</p>

<p>Next, we install <strong>pyenv-virtualenv</strong>. This simply requires checking out the repo to the <em>.pyenv/plugins/</em> directory:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/pyenv/pyenv-virtualenv.git <span class="si">$(</span>pyenv root<span class="si">)</span>/plugins/pyenv-virtualenv
</code></pre></div></div>
<p>and we then run</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">exec</span> &lt;shell&gt;
</code></pre></div></div>
<p>(in our case, <code class="language-plaintext highlighter-rouge">&lt;shell&gt;</code> is just <code class="language-plaintext highlighter-rouge">bash</code>) to restart the shell.</p>

<p>If installed with this method, upgrading is super simple - we just go the <em>.pyenv</em> directory and pull from the repo.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> <span class="si">$(</span>pyenv root<span class="si">)</span>
git pull
</code></pre></div></div>
<p>and a similar procedure follows for <strong>pyenv-virtualenv</strong>.</p>

<h3 id="usage">Usage</h3>

<p>When using <strong>pyenv</strong>, we have a <em>system</em> version of python that is present by default (python was installed by default, of course). We can install more versions by running</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv <span class="nb">install</span> &lt;version&gt;
</code></pre></div></div>
<p>where we <code class="language-plaintext highlighter-rouge">&lt;version&gt;</code> may be replaced by <code class="language-plaintext highlighter-rouge">3.8.1</code>, for instance. We can list all available versions by typing</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv <span class="nb">install</span> <span class="nt">--list</span>
</code></pre></div></div>
<p>and choose the appropriate one. After installation, this goes under <em>.pyenv/versions/{version}/</em> and all packages/virtual-environments concerning this version go under this directory. We can list the currently installed versions by</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv versions
</code></pre></div></div>
<p>The currently active version is marked by an asterisk (*). This can also be checked by running <code class="language-plaintext highlighter-rouge">pyenv version</code> instead. The output of the command will depend upon the current session or the current location. This is how <strong>pyenv</strong> chooses the python version (from the docs):</p>
<blockquote>
  <ol>
    <li>
      <p>The <em>PYENV_VERSION</em> environment variable (if specified). You can use the <code class="language-plaintext highlighter-rouge">pyenv shell</code> command to set this environment variable in your current shell session.</p>
    </li>
    <li>
      <p>The application-specific <em>.python-version</em> file in the current directory (if present). You can modify the current directory’s <em>.python-version</em> file with the <code class="language-plaintext highlighter-rouge">pyenv local</code> command.</p>
    </li>
    <li>
      <p>The first <em>.python-version</em> file found (if any) by searching each parent directory, until reaching the root of your filesystem.</p>
    </li>
    <li>
      <p>The global <em>$(pyenv root)/version</em> file. You can modify this file using the <code class="language-plaintext highlighter-rouge">pyenv global</code> command. If the global version file is not present, pyenv assumes you want to use the <em>system</em> Python. (In other words, whatever version would run if pyenv weren’t in your <em>PATH</em>.)</p>
    </li>
  </ol>
</blockquote>

<p>In other words, there are two ways to specify a python version to use:</p>
<ul>
  <li>Change the version being used for the current session by running <code class="language-plaintext highlighter-rouge">pyenv shell &lt;version&gt;</code>. Running <code class="language-plaintext highlighter-rouge">pyenv shell</code> or <code class="language-plaintext highlighter-rouge">pyenv version</code> would now show <code class="language-plaintext highlighter-rouge">&lt;version&gt;</code> as output. For this session, until changed, this version will be used for running python scripts. We can run <code class="language-plaintext highlighter-rouge">pyenv shell --unset</code> to revert to the shell being originally used before any such commands were executed. <em>This choice has the higest precedence.</em></li>
  <li>Create a <em>.python-version</em> file by running <code class="language-plaintext highlighter-rouge">pyenv local &lt;version&gt;</code> in a project directory. Whenever scripts are run from this directory, or <em>any</em> subdirectories, the chosen version will always be used, considering no shell version has been configured for the session. One can set multiple versions in decreasing order of precedence by running <code class="language-plaintext highlighter-rouge">pyenv local &lt;version-1&gt; &lt;version-2&gt; ...</code>  in a directory. Again, running <code class="language-plaintext highlighter-rouge">pyenv local</code> or <code class="language-plaintext highlighter-rouge">pyenv version</code> would now show the active versions as output. To unset this file/config, run <code class="language-plaintext highlighter-rouge">pyenv local --unset</code>.</li>
</ul>

<p>To uninstall a python version, we can either run <code class="language-plaintext highlighter-rouge">pyenv uninstall &lt;version&gt;</code> or remove the entire <em>{version}/</em> directory in <em>.pyenv/versions/</em>.</p>

<p>To create virtual environments (our original concern!), we run the command</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv virtualenv &lt;version&gt; &lt;env-name&gt;
</code></pre></div></div>
<p>i.e. we select a <code class="language-plaintext highlighter-rouge">&lt;version&gt;</code> and specify the name <code class="language-plaintext highlighter-rouge">&lt;env-name&gt;</code> of the virtual environment we want to create. We can omit <code class="language-plaintext highlighter-rouge">&lt;version&gt;</code>: in that case, the version currently set will be used to create the virtual environment, as determined by our configuration. The packages installed under this environment will be listed under the directory <em>.pyenv/versions/{version}/envs/{env-name}</em>. To activate this environment, we run</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv activate &lt;env-name&gt;
</code></pre></div></div>
<p>and <code class="language-plaintext highlighter-rouge">pyenv deactivate</code> to - well, deactivate the environment. To list created virtual environments, we run <code class="language-plaintext highlighter-rouge">pyenv virtualenvs</code>. It is possible to specify a virtual environment in a local <em>.python-version</em> file by running</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv <span class="nb">local</span> &lt;env-name&gt;
</code></pre></div></div>
<p>As mentioned before, we can list multiple python versions, environments etc. separated by spaces.</p>

<p>To remove an environment altogether, we can run</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv virtualenv-delete &lt;env-name&gt;
</code></pre></div></div>
<p>or just delete the <em>{env-name}</em> directory in <em>.pyenv/versions/{version}/envs/</em>.</p>

<p>After activating, we might want to install necessary packages. One could do this using a <em>requirements</em> text file which lists specific versions of packages (perhaps a natural use-case in virtual environments), passed to <code class="language-plaintext highlighter-rouge">pip</code>:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install</span> <span class="nt">-r</span> requirements.txt
</code></pre></div></div>
<p>It could be helpful to use a <code class="language-plaintext highlighter-rouge">--no-cache-dir</code> option if <code class="language-plaintext highlighter-rouge">pip</code> uses cached versions which do not match the required version.<sup id="fnref:cache" role="doc-noteref"><a href="#fn:cache" class="footnote" rel="footnote">2</a></sup></p>

<h3 id="installing-ipython-kernel">Installing ipython kernel</h3>

<p>Finally, we could install an <strong>ipython kernel</strong> for a virtual environment, if we use <strong>jupyter notebook</strong> installed for the <em>system</em> version. Installing multiple jupyter instances may in general not make sense (?). So we run</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv activate &lt;env-name&gt;
pip <span class="nb">install </span>ipykernel ipython_genutils
</code></pre></div></div>
<p><strong>Note:</strong> Depending upon the project and/or the python version, a specific version of ipykernel might be required. By installing <strong>ipython_genutils</strong> for the environment we can get away without installing <strong>ipython</strong> itself, since it will be installed for the <em>system</em> version.</p>

<p>After the installation, we may run</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python <span class="nt">-m</span> ipykernel <span class="nb">install</span> <span class="nt">--user</span> <span class="nt">--name</span><span class="o">=</span>&lt;env-kernel-name&gt;
</code></pre></div></div>
<p>where we type in a name for this kernel. It need not be identical to <code class="language-plaintext highlighter-rouge">&lt;env-name&gt;</code>. Now when we fire Jupyter Lab/notebook, this kernel should be available. We wouldn’t need to activate the virtual environment for this purpose.</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:sizeissue" role="doc-endnote">
      <p>Of course, one can ask here if this defeats the purpose of <em>not</em> installing <strong>conda</strong> - but it is probably not necessary to install all of these. It is <em>suggested</em> by the devs - the question of potential failure would probably need to be answered on a case-by-case basis. In any case, this step can probably be optimized. <em>TO BE INVESTIGATED</em> <a href="#fnref:sizeissue" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:cache" role="doc-endnote">
      <p>This may likely happen when the unlisted dependencies of the packages listed are installed from cache. However, using <code class="language-plaintext highlighter-rouge">--no-cache-dir</code> might significantly increase install times. Some details <a href="https://stackoverflow.com/questions/9510474/pip-uses-incorrect-cached-package-version-instead-of-the-user-specified-version/61762308#61762308">here</a>. <a href="#fnref:cache" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/progblog/workflow/2022/03/26/pyenv-virtualenv.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/progblog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">ProgBlog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">ProgBlog</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/amzon-ex"><svg class="svg-icon"><use xlink:href="/progblog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">amzon-ex</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>A blog documenting progress</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
